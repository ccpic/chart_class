"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/canvas/page",{

/***/ "(app-pages-browser)/./store/canvasStore.ts":
/*!******************************!*\
  !*** ./store/canvasStore.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCanvasStore: function() { return /* binding */ useCanvasStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/**\r\n * Canvas 画布状态管理\r\n * 使用 Zustand 实现简洁的全局状态管理\r\n */ \nconst defaultCanvas = {\n    width: 15,\n    height: 6,\n    rows: 1,\n    cols: 1,\n    wspace: 0.1,\n    hspace: 0.1,\n    fontsize: 14,\n    showLegend: false,\n    legendLoc: \"center left\",\n    legendNcol: 1,\n    bboxToAnchor: [\n        1,\n        0.5\n    ],\n    labelOuter: false,\n    dpi: 400,\n    transparent: true\n};\nconst useCanvasStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)((set, get)=>({\n        canvas: defaultCanvas,\n        subplots: [],\n        selectedSubplotId: null,\n        currentSubplotId: null,\n        updateCanvas: (config)=>set((state)=>({\n                    canvas: {\n                        ...state.canvas,\n                        ...config\n                    }\n                })),\n        addSubplot: function(axIndex) {\n            let chartType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"bar\";\n            // 根据图表类型设置默认参数\n            let defaultParams = {};\n            if (chartType === \"bubble\") {\n                defaultParams = {\n                    alpha: 0.6,\n                    bubble_scale: 1,\n                    edgecolor: \"black\",\n                    random_color: false,\n                    show_reg: false,\n                    show_hist: false,\n                    corr: null,\n                    label_limit: 0,\n                    label_formatter: \"{index}\",\n                    x_avg: null,\n                    y_avg: null,\n                    avg_linestyle: \"--\",\n                    avg_linewidth: 1,\n                    avg_color: \"gray\"\n                };\n            }\n            const newSubplot = {\n                subplotId: \"subplot-\".concat(Date.now()),\n                axIndex,\n                chartType,\n                data: {\n                    columns: [],\n                    data: []\n                },\n                params: defaultParams\n            };\n            set((state)=>({\n                    subplots: [\n                        ...state.subplots,\n                        newSubplot\n                    ],\n                    selectedSubplotId: newSubplot.subplotId\n                }));\n        },\n        updateSubplot: (subplotId, updates)=>set((state)=>({\n                    subplots: state.subplots.map((subplot)=>subplot.subplotId === subplotId ? {\n                            ...subplot,\n                            ...updates\n                        } : subplot)\n                })),\n        updateSubplotData: (subplotId, data)=>set((state)=>({\n                    subplots: state.subplots.map((subplot)=>subplot.subplotId === subplotId ? {\n                            ...subplot,\n                            data\n                        } : subplot)\n                })),\n        deleteSubplot: (subplotId)=>set((state)=>({\n                    subplots: state.subplots.filter((s)=>s.subplotId !== subplotId),\n                    selectedSubplotId: state.selectedSubplotId === subplotId ? null : state.selectedSubplotId,\n                    currentSubplotId: state.currentSubplotId === subplotId ? null : state.currentSubplotId\n                })),\n        selectSubplot: (subplotId)=>set({\n                selectedSubplotId: subplotId\n            }),\n        setCurrentSubplot: (subplotId)=>set({\n                currentSubplotId: subplotId\n            }),\n        clearAllSubplots: ()=>set({\n                subplots: [],\n                selectedSubplotId: null,\n                currentSubplotId: null\n            }),\n        duplicateSubplot: (subplotId, newAxIndex)=>{\n            const state = get();\n            const original = state.subplots.find((s)=>s.subplotId === subplotId);\n            if (!original) return;\n            const duplicated = {\n                ...original,\n                subplotId: \"subplot-\".concat(Date.now()),\n                axIndex: newAxIndex\n            };\n            set((state)=>({\n                    subplots: [\n                        ...state.subplots,\n                        duplicated\n                    ]\n                }));\n        },\n        getSubplotByAxIndex: (axIndex)=>{\n            const state = get();\n            return state.subplots.find((s)=>s.axIndex === axIndex);\n        },\n        getSubplotById: (subplotId)=>{\n            const state = get();\n            return state.subplots.find((s)=>s.subplotId === subplotId);\n        },\n        getEmptyGridCells: ()=>{\n            const state = get();\n            const total = state.canvas.rows * state.canvas.cols;\n            const occupied = state.subplots.map((s)=>s.axIndex);\n            const empty = [];\n            for(let i = 0; i < total; i++){\n                if (!occupied.includes(i)) {\n                    empty.push(i);\n                }\n            }\n            return empty;\n        },\n        isDataComplete: (subplotId)=>{\n            const state = get();\n            const subplot = state.subplots.find((s)=>s.subplotId === subplotId);\n            if (!subplot) return false;\n            return subplot.data.columns.length > 0 && subplot.data.data.length > 0;\n        },\n        canRender: ()=>{\n            const state = get();\n            return state.subplots.length > 0 && state.subplots.every((s)=>s.data.columns.length > 0 && s.data.data.length > 0);\n        },\n        saveToLocalStorage: ()=>{\n            const state = get();\n            try {\n                localStorage.setItem(\"chart-class-canvas\", JSON.stringify({\n                    canvas: state.canvas,\n                    subplots: state.subplots\n                }));\n            } catch (error) {\n                console.error(\"Failed to save to localStorage:\", error);\n            }\n        },\n        loadFromLocalStorage: ()=>{\n            try {\n                const saved = localStorage.getItem(\"chart-class-canvas\");\n                if (saved) {\n                    const { canvas, subplots } = JSON.parse(saved);\n                    set({\n                        canvas,\n                        subplots\n                    });\n                }\n            } catch (error) {\n                console.error(\"Failed to load from localStorage:\", error);\n            }\n        },\n        reset: ()=>set({\n                canvas: {\n                    ...defaultCanvas\n                },\n                subplots: [],\n                selectedSubplotId: null,\n                currentSubplotId: null\n            })\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL2NhbnZhc1N0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7OztDQUdDLEdBRWdDO0FBMkNqQyxNQUFNQyxnQkFBOEI7SUFDbENDLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFVBQVU7SUFDVkMsWUFBWTtJQUNaQyxXQUFXO0lBQ1hDLFlBQVk7SUFDWkMsY0FBYztRQUFDO1FBQUc7S0FBSTtJQUN0QkMsWUFBWTtJQUNaQyxLQUFLO0lBQ0xDLGFBQWE7QUFDZjtBQUVPLE1BQU1DLGlCQUFpQmhCLCtDQUFNQSxDQUFjLENBQUNpQixLQUFLQyxNQUFTO1FBQy9EQyxRQUFRbEI7UUFDUm1CLFVBQVUsRUFBRTtRQUNaQyxtQkFBbUI7UUFDbkJDLGtCQUFrQjtRQUVsQkMsY0FBYyxDQUFDQyxTQUNiUCxJQUFJLENBQUNRLFFBQVc7b0JBQ2ROLFFBQVE7d0JBQUUsR0FBR00sTUFBTU4sTUFBTTt3QkFBRSxHQUFHSyxNQUFNO29CQUFDO2dCQUN2QztRQUVGRSxZQUFZLFNBQUNDO2dCQUFTQyw2RUFBWTtZQUNoQyxlQUFlO1lBQ2YsSUFBSUMsZ0JBQWdCLENBQUM7WUFDckIsSUFBSUQsY0FBYyxVQUFVO2dCQUMxQkMsZ0JBQWdCO29CQUNkQyxPQUFPO29CQUNQQyxjQUFjO29CQUNkQyxXQUFXO29CQUNYQyxjQUFjO29CQUNkQyxVQUFVO29CQUNWQyxXQUFXO29CQUNYQyxNQUFNO29CQUNOQyxhQUFhO29CQUNiQyxpQkFBaUI7b0JBQ2pCQyxPQUFPO29CQUNQQyxPQUFPO29CQUNQQyxlQUFlO29CQUNmQyxlQUFlO29CQUNmQyxXQUFXO2dCQUNiO1lBQ0Y7WUFFQSxNQUFNQyxhQUE0QjtnQkFDaENDLFdBQVcsV0FBc0IsT0FBWEMsS0FBS0MsR0FBRztnQkFDOUJwQjtnQkFDQUM7Z0JBQ0FvQixNQUFNO29CQUNKQyxTQUFTLEVBQUU7b0JBQ1hELE1B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QUFPLElBQ0wxRSxJQUFJO2dCQUNGRSxRQUFRO29CQUFFLEdBQUdsQixhQUFhO2dCQUFDO2dCQUMzQm1CLFVBQVUsRUFBRTtnQkFDWkMsbUJBQW1CO2dCQUNuQkMsa0JBQWtCO1lBQ3BCO0lBQ0osSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zdG9yZS9jYW52YXNTdG9yZS50cz8wNDgxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDYW52YXMg55S75biD54q25oCB566h55CGXHJcbiAqIOS9v+eUqCBadXN0YW5kIOWunueOsOeugOa0geeahOWFqOWxgOeKtuaAgeeuoeeQhlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGNyZWF0ZSB9IGZyb20gXCJ6dXN0YW5kXCI7XHJcbmltcG9ydCB7IENhbnZhc0NvbmZpZywgU3VicGxvdENvbmZpZywgQ2hhcnRUeXBlIH0gZnJvbSBcIkAvdHlwZXMvY2FudmFzXCI7XHJcblxyXG5pbnRlcmZhY2UgQ2FudmFzU3RvcmUge1xyXG4gIC8vIOeKtuaAgVxyXG4gIGNhbnZhczogQ2FudmFzQ29uZmlnO1xyXG4gIHN1YnBsb3RzOiBTdWJwbG90Q29uZmlnW107XHJcbiAgc2VsZWN0ZWRTdWJwbG90SWQ6IHN0cmluZyB8IG51bGw7XHJcbiAgY3VycmVudFN1YnBsb3RJZDogc3RyaW5nIHwgbnVsbDsgLy8g5b2T5YmN5q2j5Zyo57yW6L6R55qE5a2Q5Zu+77yI55So5LqO6Lev55Sx5ZCM5q2l77yJXHJcblxyXG4gIC8vIENhbnZhcyBBY3Rpb25zXHJcbiAgdXBkYXRlQ2FudmFzOiAoY29uZmlnOiBQYXJ0aWFsPENhbnZhc0NvbmZpZz4pID0+IHZvaWQ7XHJcblxyXG4gIC8vIFN1YnBsb3QgQWN0aW9uc1xyXG4gIGFkZFN1YnBsb3Q6IChheEluZGV4OiBudW1iZXIsIGNoYXJ0VHlwZT86IENoYXJ0VHlwZSkgPT4gdm9pZDtcclxuICB1cGRhdGVTdWJwbG90OiAoc3VicGxvdElkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8U3VicGxvdENvbmZpZz4pID0+IHZvaWQ7XHJcbiAgdXBkYXRlU3VicGxvdERhdGE6IChcclxuICAgIHN1YnBsb3RJZDogc3RyaW5nLFxyXG4gICAgZGF0YTogeyBjb2x1bW5zOiBzdHJpbmdbXTsgZGF0YTogYW55W11bXSB9XHJcbiAgKSA9PiB2b2lkO1xyXG4gIGRlbGV0ZVN1YnBsb3Q6IChzdWJwbG90SWQ6IHN0cmluZykgPT4gdm9pZDtcclxuICBzZWxlY3RTdWJwbG90OiAoc3VicGxvdElkOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xyXG4gIHNldEN1cnJlbnRTdWJwbG90OiAoc3VicGxvdElkOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xyXG5cclxuICAvLyDmibnph4/mk43kvZxcclxuICBjbGVhckFsbFN1YnBsb3RzOiAoKSA9PiB2b2lkO1xyXG4gIGR1cGxpY2F0ZVN1YnBsb3Q6IChzdWJwbG90SWQ6IHN0cmluZywgbmV3QXhJbmRleDogbnVtYmVyKSA9PiB2b2lkO1xyXG5cclxuICAvLyDlt6Xlhbfmlrnms5VcclxuICBnZXRTdWJwbG90QnlBeEluZGV4OiAoYXhJbmRleDogbnVtYmVyKSA9PiBTdWJwbG90Q29uZmlnIHwgdW5kZWZpbmVkO1xyXG4gIGdldFN1YnBsb3RCeUlkOiAoc3VicGxvdElkOiBzdHJpbmcpID0+IFN1YnBsb3RDb25maWcgfCB1bmRlZmluZWQ7XHJcbiAgZ2V0RW1wdHlHcmlkQ2VsbHM6ICgpID0+IG51bWJlcltdO1xyXG4gIGlzRGF0YUNvbXBsZXRlOiAoc3VicGxvdElkOiBzdHJpbmcpID0+IGJvb2xlYW47XHJcbiAgY2FuUmVuZGVyOiAoKSA9PiBib29sZWFuO1xyXG5cclxuICAvLyDmnKzlnLDlrZjlgqjvvIjlj6/pgInvvIlcclxuICBzYXZlVG9Mb2NhbFN0b3JhZ2U6ICgpID0+IHZvaWQ7XHJcbiAgbG9hZEZyb21Mb2NhbFN0b3JhZ2U6ICgpID0+IHZvaWQ7XHJcblxyXG4gIC8vIOmHjee9rlxyXG4gIHJlc2V0OiAoKSA9PiB2b2lkO1xyXG59XHJcblxyXG5jb25zdCBkZWZhdWx0Q2FudmFzOiBDYW52YXNDb25maWcgPSB7XHJcbiAgd2lkdGg6IDE1LFxyXG4gIGhlaWdodDogNixcclxuICByb3dzOiAxLFxyXG4gIGNvbHM6IDEsXHJcbiAgd3NwYWNlOiAwLjEsXHJcbiAgaHNwYWNlOiAwLjEsXHJcbiAgZm9udHNpemU6IDE0LFxyXG4gIHNob3dMZWdlbmQ6IGZhbHNlLFxyXG4gIGxlZ2VuZExvYzogXCJjZW50ZXIgbGVmdFwiLFxyXG4gIGxlZ2VuZE5jb2w6IDEsXHJcbiAgYmJveFRvQW5jaG9yOiBbMSwgMC41XSxcclxuICBsYWJlbE91dGVyOiBmYWxzZSxcclxuICBkcGk6IDQwMCxcclxuICB0cmFuc3BhcmVudDogdHJ1ZSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VDYW52YXNTdG9yZSA9IGNyZWF0ZTxDYW52YXNTdG9yZT4oKHNldCwgZ2V0KSA9PiAoe1xyXG4gIGNhbnZhczogZGVmYXVsdENhbnZhcyxcclxuICBzdWJwbG90czogW10sXHJcbiAgc2VsZWN0ZWRTdWJwbG90SWQ6IG51bGwsXHJcbiAgY3VycmVudFN1YnBsb3RJZDogbnVsbCxcclxuXHJcbiAgdXBkYXRlQ2FudmFzOiAoY29uZmlnKSA9PlxyXG4gICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgY2FudmFzOiB7IC4uLnN0YXRlLmNhbnZhcywgLi4uY29uZmlnIH0sXHJcbiAgICB9KSksXHJcblxyXG4gIGFkZFN1YnBsb3Q6IChheEluZGV4LCBjaGFydFR5cGUgPSBcImJhclwiKSA9PiB7XHJcbiAgICAvLyDmoLnmja7lm77ooajnsbvlnovorr7nva7pu5jorqTlj4LmlbBcclxuICAgIGxldCBkZWZhdWx0UGFyYW1zID0ge307XHJcbiAgICBpZiAoY2hhcnRUeXBlID09PSBcImJ1YmJsZVwiKSB7XHJcbiAgICAgIGRlZmF1bHRQYXJhbXMgPSB7XHJcbiAgICAgICAgYWxwaGE6IDAuNixcclxuICAgICAgICBidWJibGVfc2NhbGU6IDEsXHJcbiAgICAgICAgZWRnZWNvbG9yOiBcImJsYWNrXCIsXHJcbiAgICAgICAgcmFuZG9tX2NvbG9yOiBmYWxzZSxcclxuICAgICAgICBzaG93X3JlZzogZmFsc2UsXHJcbiAgICAgICAgc2hvd19oaXN0OiBmYWxzZSxcclxuICAgICAgICBjb3JyOiBudWxsLFxyXG4gICAgICAgIGxhYmVsX2xpbWl0OiAwLFxyXG4gICAgICAgIGxhYmVsX2Zvcm1hdHRlcjogXCJ7aW5kZXh9XCIsXHJcbiAgICAgICAgeF9hdmc6IG51bGwsXHJcbiAgICAgICAgeV9hdmc6IG51bGwsXHJcbiAgICAgICAgYXZnX2xpbmVzdHlsZTogXCItLVwiLFxyXG4gICAgICAgIGF2Z19saW5ld2lkdGg6IDEsXHJcbiAgICAgICAgYXZnX2NvbG9yOiBcImdyYXlcIixcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuZXdTdWJwbG90OiBTdWJwbG90Q29uZmlnID0ge1xyXG4gICAgICBzdWJwbG90SWQ6IGBzdWJwbG90LSR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICBheEluZGV4LFxyXG4gICAgICBjaGFydFR5cGUsXHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICBjb2x1bW5zOiBbXSxcclxuICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgfSxcclxuICAgICAgcGFyYW1zOiBkZWZhdWx0UGFyYW1zLFxyXG4gICAgfTtcclxuICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgIHN1YnBsb3RzOiBbLi4uc3RhdGUuc3VicGxvdHMsIG5ld1N1YnBsb3RdLFxyXG4gICAgICBzZWxlY3RlZFN1YnBsb3RJZDogbmV3U3VicGxvdC5zdWJwbG90SWQsXHJcbiAgICB9KSk7XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlU3VicGxvdDogKHN1YnBsb3RJZCwgdXBkYXRlcykgPT5cclxuICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgIHN1YnBsb3RzOiBzdGF0ZS5zdWJwbG90cy5tYXAoKHN1YnBsb3QpID0+XHJcbiAgICAgICAgc3VicGxvdC5zdWJwbG90SWQgPT09IHN1YnBsb3RJZCA/IHsgLi4uc3VicGxvdCwgLi4udXBkYXRlcyB9IDogc3VicGxvdFxyXG4gICAgICApLFxyXG4gICAgfSkpLFxyXG5cclxuICB1cGRhdGVTdWJwbG90RGF0YTogKHN1YnBsb3RJZCwgZGF0YSkgPT5cclxuICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgIHN1YnBsb3RzOiBzdGF0ZS5zdWJwbG90cy5tYXAoKHN1YnBsb3QpID0+XHJcbiAgICAgICAgc3VicGxvdC5zdWJwbG90SWQgPT09IHN1YnBsb3RJZCA/IHsgLi4uc3VicGxvdCwgZGF0YSB9IDogc3VicGxvdFxyXG4gICAgICApLFxyXG4gICAgfSkpLFxyXG5cclxuICBkZWxldGVTdWJwbG90OiAoc3VicGxvdElkKSA9PlxyXG4gICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgc3VicGxvdHM6IHN0YXRlLnN1YnBsb3RzLmZpbHRlcigocykgPT4gcy5zdWJwbG90SWQgIT09IHN1YnBsb3RJZCksXHJcbiAgICAgIHNlbGVjdGVkU3VicGxvdElkOlxyXG4gICAgICAgIHN0YXRlLnNlbGVjdGVkU3VicGxvdElkID09PSBzdWJwbG90SWQgPyBudWxsIDogc3RhdGUuc2VsZWN0ZWRTdWJwbG90SWQsXHJcbiAgICAgIGN1cnJlbnRTdWJwbG90SWQ6XHJcbiAgICAgICAgc3RhdGUuY3VycmVudFN1YnBsb3RJZCA9PT0gc3VicGxvdElkID8gbnVsbCA6IHN0YXRlLmN1cnJlbnRTdWJwbG90SWQsXHJcbiAgICB9KSksXHJcblxyXG4gIHNlbGVjdFN1YnBsb3Q6IChzdWJwbG90SWQpID0+IHNldCh7IHNlbGVjdGVkU3VicGxvdElkOiBzdWJwbG90SWQgfSksXHJcblxyXG4gIHNldEN1cnJlbnRTdWJwbG90OiAoc3VicGxvdElkKSA9PiBzZXQoeyBjdXJyZW50U3VicGxvdElkOiBzdWJwbG90SWQgfSksXHJcblxyXG4gIGNsZWFyQWxsU3VicGxvdHM6ICgpID0+XHJcbiAgICBzZXQoe1xyXG4gICAgICBzdWJwbG90czogW10sXHJcbiAgICAgIHNlbGVjdGVkU3VicGxvdElkOiBudWxsLFxyXG4gICAgICBjdXJyZW50U3VicGxvdElkOiBudWxsLFxyXG4gICAgfSksXHJcblxyXG4gIGR1cGxpY2F0ZVN1YnBsb3Q6IChzdWJwbG90SWQsIG5ld0F4SW5kZXgpID0+IHtcclxuICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XHJcbiAgICBjb25zdCBvcmlnaW5hbCA9IHN0YXRlLnN1YnBsb3RzLmZpbmQoKHMpID0+IHMuc3VicGxvdElkID09PSBzdWJwbG90SWQpO1xyXG4gICAgaWYgKCFvcmlnaW5hbCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGR1cGxpY2F0ZWQ6IFN1YnBsb3RDb25maWcgPSB7XHJcbiAgICAgIC4uLm9yaWdpbmFsLFxyXG4gICAgICBzdWJwbG90SWQ6IGBzdWJwbG90LSR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICBheEluZGV4OiBuZXdBeEluZGV4LFxyXG4gICAgfTtcclxuICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgIHN1YnBsb3RzOiBbLi4uc3RhdGUuc3VicGxvdHMsIGR1cGxpY2F0ZWRdLFxyXG4gICAgfSkpO1xyXG4gIH0sXHJcblxyXG4gIGdldFN1YnBsb3RCeUF4SW5kZXg6IChheEluZGV4KSA9PiB7XHJcbiAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xyXG4gICAgcmV0dXJuIHN0YXRlLnN1YnBsb3RzLmZpbmQoKHMpID0+IHMuYXhJbmRleCA9PT0gYXhJbmRleCk7XHJcbiAgfSxcclxuXHJcbiAgZ2V0U3VicGxvdEJ5SWQ6IChzdWJwbG90SWQpID0+IHtcclxuICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XHJcbiAgICByZXR1cm4gc3RhdGUuc3VicGxvdHMuZmluZCgocykgPT4gcy5zdWJwbG90SWQgPT09IHN1YnBsb3RJZCk7XHJcbiAgfSxcclxuXHJcbiAgZ2V0RW1wdHlHcmlkQ2VsbHM6ICgpID0+IHtcclxuICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XHJcbiAgICBjb25zdCB0b3RhbCA9IHN0YXRlLmNhbnZhcy5yb3dzICogc3RhdGUuY2FudmFzLmNvbHM7XHJcbiAgICBjb25zdCBvY2N1cGllZCA9IHN0YXRlLnN1YnBsb3RzLm1hcCgocykgPT4gcy5heEluZGV4KTtcclxuICAgIGNvbnN0IGVtcHR5OiBudW1iZXJbXSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XHJcbiAgICAgIGlmICghb2NjdXBpZWQuaW5jbHVkZXMoaSkpIHtcclxuICAgICAgICBlbXB0eS5wdXNoKGkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW1wdHk7XHJcbiAgfSxcclxuXHJcbiAgaXNEYXRhQ29tcGxldGU6IChzdWJwbG90SWQpID0+IHtcclxuICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XHJcbiAgICBjb25zdCBzdWJwbG90ID0gc3RhdGUuc3VicGxvdHMuZmluZCgocykgPT4gcy5zdWJwbG90SWQgPT09IHN1YnBsb3RJZCk7XHJcbiAgICBpZiAoIXN1YnBsb3QpIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiBzdWJwbG90LmRhdGEuY29sdW1ucy5sZW5ndGggPiAwICYmIHN1YnBsb3QuZGF0YS5kYXRhLmxlbmd0aCA+IDA7XHJcbiAgfSxcclxuXHJcbiAgY2FuUmVuZGVyOiAoKSA9PiB7XHJcbiAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgc3RhdGUuc3VicGxvdHMubGVuZ3RoID4gMCAmJlxyXG4gICAgICBzdGF0ZS5zdWJwbG90cy5ldmVyeShcclxuICAgICAgICAocykgPT4gcy5kYXRhLmNvbHVtbnMubGVuZ3RoID4gMCAmJiBzLmRhdGEuZGF0YS5sZW5ndGggPiAwXHJcbiAgICAgIClcclxuICAgICk7XHJcbiAgfSxcclxuXHJcbiAgc2F2ZVRvTG9jYWxTdG9yYWdlOiAoKSA9PiB7XHJcbiAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXHJcbiAgICAgICAgXCJjaGFydC1jbGFzcy1jYW52YXNcIixcclxuICAgICAgICBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBjYW52YXM6IHN0YXRlLmNhbnZhcyxcclxuICAgICAgICAgIHN1YnBsb3RzOiBzdGF0ZS5zdWJwbG90cyxcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzYXZlIHRvIGxvY2FsU3RvcmFnZTpcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGxvYWRGcm9tTG9jYWxTdG9yYWdlOiAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzYXZlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiY2hhcnQtY2xhc3MtY2FudmFzXCIpO1xyXG4gICAgICBpZiAoc2F2ZWQpIHtcclxuICAgICAgICBjb25zdCB7IGNhbnZhcywgc3VicGxvdHMgfSA9IEpTT04ucGFyc2Uoc2F2ZWQpO1xyXG4gICAgICAgIHNldCh7IGNhbnZhcywgc3VicGxvdHMgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBmcm9tIGxvY2FsU3RvcmFnZTpcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHJlc2V0OiAoKSA9PlxyXG4gICAgc2V0KHtcclxuICAgICAgY2FudmFzOiB7IC4uLmRlZmF1bHRDYW52YXMgfSxcclxuICAgICAgc3VicGxvdHM6IFtdLFxyXG4gICAgICBzZWxlY3RlZFN1YnBsb3RJZDogbnVsbCxcclxuICAgICAgY3VycmVudFN1YnBsb3RJZDogbnVsbCxcclxuICAgIH0pLFxyXG59KSk7XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJkZWZhdWx0Q2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJyb3dzIiwiY29scyIsIndzcGFjZSIsImhzcGFjZSIsImZvbnRzaXplIiwic2hvd0xlZ2VuZCIsImxlZ2VuZExvYyIsImxlZ2VuZE5jb2wiLCJiYm94VG9BbmNob3IiLCJsYWJlbE91dGVyIiwiZHBpIiwidHJhbnNwYXJlbnQiLCJ1c2VDYW52YXNTdG9yZSIsInNldCIsImdldCIsImNhbnZhcyIsInN1YnBsb3RzIiwic2VsZWN0ZWRTdWJwbG90SWQiLCJjdXJyZW50U3VicGxvdElkIiwidXBkYXRlQ2FudmFzIiwiY29uZmlnIiwic3RhdGUiLCJhZGRTdWJwbG90IiwiYXhJbmRleCIsImNoYXJ0VHlwZSIsImRlZmF1bHRQYXJhbXMiLCJhbHBoYSIsImJ1YmJsZV9zY2FsZSIsImVkZ2Vjb2xvciIsInJhbmRvbV9jb2xvciIsInNob3dfcmVnIiwic2hvd19oaXN0IiwiY29yciIsImxhYmVsX2xpbWl0IiwibGFiZWxfZm9ybWF0dGVyIiwieF9hdmciLCJ5X2F2ZyIsImF2Z19saW5lc3R5bGUiLCJhdmdfbGluZXdpZHRoIiwiYXZnX2NvbG9yIiwibmV3U3VicGxvdCIsInN1YnBsb3RJZCIsIkRhdGUiLCJub3ciLCJkYXRhIiwiY29sdW1ucyIsInBhcmFtcyIsInVwZGF0ZVN1YnBsb3QiLCJ1cGRhdGVzIiwibWFwIiwic3VicGxvdCIsInVwZGF0ZVN1YnBsb3REYXRhIiwiZGVsZXRlU3VicGxvdCIsImZpbHRlciIsInMiLCJzZWxlY3RTdWJwbG90Iiwic2V0Q3VycmVudFN1YnBsb3QiLCJjbGVhckFsbFN1YnBsb3RzIiwiZHVwbGljYXRlU3VicGxvdCIsIm5ld0F4SW5kZXgiLCJvcmlnaW5hbCIsImZpbmQiLCJkdXBsaWNhdGVkIiwiZ2V0U3VicGxvdEJ5QXhJbmRleCIsImdldFN1YnBsb3RCeUlkIiwiZ2V0RW1wdHlHcmlkQ2VsbHMiLCJ0b3RhbCIsIm9jY3VwaWVkIiwiZW1wdHkiLCJpIiwiaW5jbHVkZXMiLCJwdXNoIiwiaXNEYXRhQ29tcGxldGUiLCJsZW5ndGgiLCJjYW5SZW5kZXIiLCJldmVyeSIsInNhdmVUb0xvY2FsU3RvcmFnZSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJjb25zb2xlIiwibG9hZEZyb21Mb2NhbFN0b3JhZ2UiLCJzYXZlZCIsImdldEl0ZW0iLCJwYXJzZSIsInJlc2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/canvasStore.ts\n"));

/***/ })

});